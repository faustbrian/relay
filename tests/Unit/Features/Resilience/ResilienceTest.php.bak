<?php declare(strict_types=1);

/**
 * Copyright (C) Brian Faust
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Cline\Relay\Attributes\Resilience\CircuitBreaker as CircuitBreakerAttr;
use Cline\Relay\Attributes\Resilience\Retry;
use Cline\Relay\Attributes\Resilience\Timeout;
use Cline\Relay\Exceptions\CircuitOpenException;
use Cline\Relay\Request;
use Cline\Relay\Resilience\CircuitBreaker;
use Cline\Relay\Resilience\CircuitBreakerConfig;
use Cline\Relay\Resilience\CircuitState;
use Cline\Relay\Resilience\MemoryCircuitStore;
use Cline\Relay\Resilience\RetryConfig;
use Cline\Relay\Resilience\RetryHandler;
use Cline\Relay\Response;
use Illuminate\Support\Facades\Date;

describe('Timeout Attribute', function (): void {
    it('sets timeout in seconds', function (): void {
        $timeout = new Timeout(seconds: 30);

        expect($timeout->seconds)->toBe(30);
    });

    it('sets separate connect and read timeouts', function (): void {
        $timeout = new Timeout(seconds: 30, connect: 5, read: 25);

        expect($timeout->seconds)->toBe(30);
        expect($timeout->connect)->toBe(5);
        expect($timeout->read)->toBe(25);
    });
});

describe('Retry Attribute', function (): void {
    it('sets retry times', function (): void {
        $retry = new Retry(times: 5);

        expect($retry->times)->toBe(5);
    });

    it('configures exponential backoff', function (): void {
        $retry = new Retry(
            times: 3,
            delay: 1_000,
            multiplier: 2.0,
            maxDelay: 30_000,
        );

        expect($retry->times)->toBe(3);
        expect($retry->delay)->toBe(1_000);
        expect($retry->multiplier)->toBe(2.0);
        expect($retry->maxDelay)->toBe(30_000);
    });

    it('accepts status codes to retry on', function (): void {
        $retry = new Retry(times: 3, when: [500, 502, 503]);

        expect($retry->when)->toBe([500, 502, 503]);
    });
});

describe('CircuitBreaker Attribute', function (): void {
    it('sets failure threshold', function (): void {
        $cb = new CircuitBreakerAttr(failureThreshold: 10);

        expect($cb->failureThreshold)->toBe(10);
    });

    it('configures reset timeout', function (): void {
        $cb = new CircuitBreakerAttr(
            failureThreshold: 5,
            resetTimeout: 60,
            halfOpenRequests: 3,
        );

        expect($cb->resetTimeout)->toBe(60);
        expect($cb->halfOpenRequests)->toBe(3);
    });
});

describe('RetryConfig', function (): void {
    it('creates with default values', function (): void {
        $config = new RetryConfig();

        expect($config->times)->toBe(3);
        expect($config->delay)->toBe(100);
        expect($config->multiplier)->toBe(2.0);
    });

    it('accepts custom configuration', function (): void {
        $config = new RetryConfig(
            times: 5,
            delay: 500,
            multiplier: 1.5,
            statusCodes: [500, 502],
        );

        expect($config->times)->toBe(5);
        expect($config->delay)->toBe(500);
        expect($config->statusCodes)->toBe([500, 502]);
    });
});

describe('RetryHandler', function (): void {
    it('calculates exponential backoff delay', function (): void {
        $config = new RetryConfig(delay: 100, multiplier: 2.0, maxDelay: 10_000);
        $handler = new RetryHandler($config);

        $request = new class() extends Request
        {
            public function endpoint(): string
            {
                return '/test';
            }
        };

        expect($handler->calculateDelay($request, 1))->toBe(100);
        expect($handler->calculateDelay($request, 2))->toBe(200);
        expect($handler->calculateDelay($request, 3))->toBe(400);
    });

    it('respects max delay', function (): void {
        $config = new RetryConfig(delay: 1_000, multiplier: 10.0, maxDelay: 5_000);
        $handler = new RetryHandler($config);

        $request = new class() extends Request
        {
            public function endpoint(): string
            {
                return '/test';
            }
        };

        expect($handler->calculateDelay($request, 3))->toBe(5_000);
    });

    it('should retry on server error by default', function (): void {
        $config = new RetryConfig(times: 3);
        $handler = new RetryHandler($config);

        $request = new class() extends Request
        {
            public function endpoint(): string
            {
                return '/test';
            }
        };

        $response = Response::make([], 500);
        expect($handler->shouldRetryResponse($request, $response, 1))->toBeTrue();

        $response200 = Response::make([], 200);
        expect($handler->shouldRetryResponse($request, $response200, 1))->toBeFalse();
    });

    it('should not retry when max attempts reached', function (): void {
        $config = new RetryConfig(times: 2);
        $handler = new RetryHandler($config);

        $request = new class() extends Request
        {
            public function endpoint(): string
            {
                return '/test';
            }
        };

        $response = Response::make([], 500);
        expect($handler->shouldRetryResponse($request, $response, 2))->toBeFalse();
    });
});

describe('CircuitBreakerConfig', function (): void {
    it('creates with default values', function (): void {
        $config = new CircuitBreakerConfig();

        expect($config->failureThreshold)->toBe(5);
        expect($config->resetTimeout)->toBe(30);
        expect($config->halfOpenRequests)->toBe(3);
    });
});

describe('CircuitState', function (): void {
    it('has closed state', function (): void {
        expect(CircuitState::Closed->value)->toBe('closed');
    });

    it('has open state', function (): void {
        expect(CircuitState::Open->value)->toBe('open');
    });

    it('has half-open state', function (): void {
        expect(CircuitState::HalfOpen->value)->toBe('half-open');
    });
});

describe('MemoryCircuitStore', function (): void {
    it('starts in closed state', function (): void {
        $store = new MemoryCircuitStore();

        expect($store->getState('test'))->toBe(CircuitState::Closed);
    });

    it('tracks failures', function (): void {
        $store = new MemoryCircuitStore();

        $store->recordFailure('test', 60);
        $store->recordFailure('test', 60);

        expect($store->getFailureCount('test'))->toBe(2);
    });

    it('tracks successes', function (): void {
        $store = new MemoryCircuitStore();

        $store->recordSuccess('test');
        $store->recordSuccess('test');

        expect($store->getSuccessCount('test'))->toBe(2);
    });

    it('resets state', function (): void {
        $store = new MemoryCircuitStore();

        $store->setState('test', CircuitState::Open);
        $store->recordFailure('test', 60);

        $store->reset('test');

        expect($store->getState('test'))->toBe(CircuitState::Closed);
        expect($store->getFailureCount('test'))->toBe(0);
    });
});

describe('CircuitBreaker', function (): void {
    it('starts in closed state', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig();
        $breaker = new CircuitBreaker($store, $config, 'test');

        expect($breaker->state())->toBe(CircuitState::Closed);
        expect($breaker->isClosed())->toBeTrue();
    });

    it('allows requests when closed', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig();
        $breaker = new CircuitBreaker($store, $config, 'test');

        expect($breaker->allowRequest())->toBeTrue();
    });

    it('opens after failure threshold', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 3);
        $breaker = new CircuitBreaker($store, $config, 'test');

        $breaker->recordFailure();
        $breaker->recordFailure();

        expect($breaker->isClosed())->toBeTrue();

        $breaker->recordFailure();
        expect($breaker->isOpen())->toBeTrue();
    });

    it('throws when open', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1);
        $breaker = new CircuitBreaker($store, $config, 'test');

        $breaker->recordFailure();

        expect($breaker->isOpen())->toBeTrue();

        $breaker->allowRequest();
    })->throws(CircuitOpenException::class);

    it('can be manually opened', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig();
        $breaker = new CircuitBreaker($store, $config, 'test');

        $breaker->open();

        expect($breaker->isOpen())->toBeTrue();
    });

    it('can be manually closed', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1);
        $breaker = new CircuitBreaker($store, $config, 'test');

        $breaker->recordFailure();

        expect($breaker->isOpen())->toBeTrue();

        $breaker->close();

        expect($breaker->isClosed())->toBeTrue();
    });

    it('closes after successes in half-open state', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            resetTimeout: 30,
            successThreshold: 2,
        );
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Force to half-open state
        $store->setState('test', CircuitState::HalfOpen);

        // Record successes
        $breaker->recordSuccess();
        expect($breaker->isHalfOpen())->toBeTrue();

        $breaker->recordSuccess();
        expect($breaker->isClosed())->toBeTrue();
    });
});

describe('CircuitBreaker state transitions', function (): void {
    afterEach(function (): void {
        Date::setTestNow();
    });

    test('transitions from open to half-open after reset timeout', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 5);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Open the circuit
        $breaker->recordFailure();
        expect($breaker->isOpen())->toBeTrue();

        // Advance time past reset timeout
        Date::setTestNow(Date::now()->addSeconds(6));

        // Should now be half-open
        expect($breaker->isHalfOpen())->toBeTrue();
        expect($breaker->state())->toBe(CircuitState::HalfOpen);
    });

    test('does not transition to half-open before reset timeout', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 10);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Open the circuit
        $breaker->recordFailure();
        expect($breaker->isOpen())->toBeTrue();

        // Advance time but not past reset timeout
        Date::setTestNow(Date::now()->addSeconds(5));

        // Should still be open
        expect($breaker->isOpen())->toBeTrue();
        expect($breaker->state())->toBe(CircuitState::Open);
    });

    test('transitions exactly at reset timeout boundary', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 5);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Open the circuit
        $breaker->recordFailure();

        // Advance time exactly to reset timeout
        Date::setTestNow(Date::now()->addSeconds(5));

        // Should be half-open
        expect($breaker->isHalfOpen())->toBeTrue();
    });
});

describe('CircuitBreaker half-open behavior', function (): void {
    afterEach(function (): void {
        Date::setTestNow();
    });

    test('allows limited requests in half-open state', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            resetTimeout: 5,
            halfOpenRequests: 3,
        );
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Force to half-open state
        $breaker->recordFailure();
        Date::setTestNow(Date::now()->addSeconds(6));

        // Should allow up to halfOpenRequests
        expect($breaker->allowRequest())->toBeTrue();
        expect($breaker->allowRequest())->toBeTrue();
        expect($breaker->allowRequest())->toBeTrue();
    });

    test('throws CircuitOpenException when half-open capacity reached', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            resetTimeout: 5,
            halfOpenRequests: 2,
        );
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Force to half-open state
        $breaker->recordFailure();
        Date::setTestNow(Date::now()->addSeconds(6));

        // Allow first two requests
        $breaker->allowRequest();
        $breaker->allowRequest();

        // Third request should throw
        $breaker->allowRequest();
    })->throws(CircuitOpenException::class, 'Circuit breaker is half-open and at capacity');

    test('reopens circuit on failure in half-open state', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            resetTimeout: 5,
            halfOpenRequests: 3,
        );
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Force to half-open state
        $breaker->recordFailure();
        Date::setTestNow(Date::now()->addSeconds(6));

        expect($breaker->isHalfOpen())->toBeTrue();

        // Record failure in half-open state
        $breaker->recordFailure();

        // Should reopen the circuit
        expect($breaker->isOpen())->toBeTrue();
    });

    test('does not record success when in closed state', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig();
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Circuit is closed
        expect($breaker->isClosed())->toBeTrue();

        // Record success (should not affect state)
        $breaker->recordSuccess();

        // Should still be closed and success count should be 0
        expect($breaker->isClosed())->toBeTrue();
        expect($store->getSuccessCount('test'))->toBe(0);
    });
});

describe('CircuitBreaker callbacks', function (): void {
    afterEach(function (): void {
        Date::setTestNow();
    });

    test('calls onOpen callback when circuit opens', function (): void {
        $called = false;
        $callbackKey = null;

        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            onOpen: function ($key) use (&$called, &$callbackKey): void {
                $called = true;
                $callbackKey = $key;
            },
        );

        $store = new MemoryCircuitStore();
        $breaker = new CircuitBreaker($store, $config, 'test-key');

        // Open the circuit
        $breaker->recordFailure();

        expect($called)->toBeTrue();
        expect($callbackKey)->toBe('test-key');
    });

    test('calls onClose callback when circuit closes', function (): void {
        $called = false;
        $callbackKey = null;

        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            onClose: function ($key) use (&$called, &$callbackKey): void {
                $called = true;
                $callbackKey = $key;
            },
        );

        $store = new MemoryCircuitStore();
        $breaker = new CircuitBreaker($store, $config, 'test-key');

        // Open then close the circuit
        $breaker->recordFailure();
        $breaker->close();

        expect($called)->toBeTrue();
        expect($callbackKey)->toBe('test-key');
    });

    test('calls onHalfOpen callback when transitioning to half-open', function (): void {
        $called = false;
        $callbackKey = null;

        $config = new CircuitBreakerConfig(
            failureThreshold: 1,
            resetTimeout: 5,
            onHalfOpen: function ($key) use (&$called, &$callbackKey): void {
                $called = true;
                $callbackKey = $key;
            },
        );

        $store = new MemoryCircuitStore();
        $breaker = new CircuitBreaker($store, $config, 'test-key');

        // Open the circuit
        $breaker->recordFailure();

        // Advance time to trigger half-open transition
        Date::setTestNow(Date::now()->addSeconds(6));

        // Trigger state check to call halfOpen()
        $breaker->state();

        expect($called)->toBeTrue();
        expect($callbackKey)->toBe('test-key');
    });

    test('does not throw when callbacks are not configured', function (): void {
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 5);
        $store = new MemoryCircuitStore();
        $breaker = new CircuitBreaker($store, $config, 'test');

        // These should not throw even though callbacks are null
        $breaker->open();
        $breaker->close();
        $breaker->recordFailure();
        Date::setTestNow(Date::now()->addSeconds(6));
        $breaker->state(); // Triggers halfOpen()

        expect(true)->toBeTrue();
    });
});

describe('CircuitBreaker retry timing', function (): void {
    afterEach(function (): void {
        Date::setTestNow();
    });

    test('calculates retry after time when circuit is open', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 30);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Open the circuit
        $breaker->recordFailure();

        try {
            $breaker->allowRequest();
        } catch (CircuitOpenException $e) {
            // Should be close to resetTimeout (30 seconds)
            expect($e->retryAfter())->toBeGreaterThanOrEqual(29);
            expect($e->retryAfter())->toBeLessThanOrEqual(30);
        }
    });

    test('calculates decreasing retry time as time passes', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 30);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Open the circuit
        $breaker->recordFailure();

        // Advance time by 10 seconds
        Date::setTestNow(Date::now()->addSeconds(10));

        try {
            $breaker->allowRequest();
        } catch (CircuitOpenException $e) {
            // Should be approximately 20 seconds remaining
            expect($e->retryAfter())->toBeGreaterThanOrEqual(19);
            expect($e->retryAfter())->toBeLessThanOrEqual(20);
        }
    });

    test('returns zero retry time when openedAt is past reset timeout', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 10);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Open the circuit
        $breaker->recordFailure();

        // Advance time past reset timeout
        Date::setTestNow(Date::now()->addSeconds(15));

        // Should transition to half-open, but let's check the timing
        // The circuit should be half-open now, so we won't get CircuitOpenException
        expect($breaker->isHalfOpen())->toBeTrue();
    });

    test('returns reset timeout when openedAt is null', function (): void {
        $store = new MemoryCircuitStore();
        $config = new CircuitBreakerConfig(failureThreshold: 1, resetTimeout: 30);
        $breaker = new CircuitBreaker($store, $config, 'test');

        // Manually set state to Open without setting openedAt
        $store->setState('test', CircuitState::Open);

        try {
            $breaker->allowRequest();
        } catch (CircuitOpenException $e) {
            // Should return full resetTimeout when openedAt is null
            expect($e->retryAfter())->toBe(30);
        }
    });
});

describe('CircuitOpenException', function (): void {
    it('provides retry after time', function (): void {
        $exception = new CircuitOpenException('Circuit open', 30);

        expect($exception->retryAfter())->toBe(30);
        expect($exception->getMessage())->toBe('Circuit open');
    });
});
